<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>SHF: Small: Effectful Software Contracts</AwardTitle>
    <AwardEffectiveDate>08/01/2011</AwardEffectiveDate>
    <AwardExpirationDate>07/31/2014</AwardExpirationDate>
    <AwardAmount>440760</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05010000</Code>
      <Directorate>
        <LongName>Directorate for Computer &amp; Information Science &amp; Engineering</LongName>
      </Directorate>
      <Division>
        <LongName>Division of Computer and Communication Foundations</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>John Reppy</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>The long-term goals of this project are to bring the technology of software contracts to widely-used programming languages and, through&lt;br/&gt;the use of manifest contracts, to provide software developers with a migration path from simply-typed code to fully functional correctness. Since computational effects are notoriously hard to reason about and&lt;br/&gt;pervade even the simplest realistic programs, the proposed research should have significant impact on programmers' ability to develop&lt;br/&gt;software that is more reliable and more secure. &lt;br/&gt;&lt;br/&gt;Contracts in software establish clear interfaces between program components. Like contracts in the legal realm, they delineate each&lt;br/&gt;party's expectations and obligations. Such contracts are becoming increasingly important for the regulation of modern software systems,&lt;br/&gt;providing an expressive framework for verification and error tracking. To be effective in a software environment, contracts must have formal semantics and must be supported by a monitoring system that precisely&lt;br/&gt;tracks the flow of values as they cross interfaces. To date, however, the formal study of contracts has mostly been limited to small&lt;br/&gt;idealized languages without computational effects, such as reading data from or writing data to a display or file, managing resources&lt;br/&gt;such as memory, and performing probabilistic or speculative computation.&lt;br/&gt;&lt;br/&gt;This research aims to extend the semantic framework of software contracts to languages with various computational effects: the&lt;br/&gt;extension is qualitative in nature and will enable the use of contracts in new application domains. Specifically, the PIs propose&lt;br/&gt;to add support for computational effects to the two flavors of contracts studied to date: latent contracts, which are runtime checks&lt;br/&gt;not reflected in the type system, and manifest contracts, where a system of precise types records the most recent runtime check applied&lt;br/&gt;to each value. The extension of latent contracts will be done in the context of a monadic meta language. The extension of manifest&lt;br/&gt;contracts will make use of a variant of Hoare Type Theory to precisely record computational effects. The PIs will also implement prototype systems and use them to present novel applications of software&lt;br/&gt;contracts.</AbstractNarration>
    <MinAmdLetterDate>10/24/2011</MinAmdLetterDate>
    <MaxAmdLetterDate>10/24/2011</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>1203008</AwardID>
    <Investigator>
      <FirstName>Amal</FirstName>
      <LastName>Ahmed</LastName>
      <EmailAddress>amal@ccs.neu.edu</EmailAddress>
      <StartDate>10/24/2011</StartDate>
      <EndDate/>
      <RoleCode>1</RoleCode>
    </Investigator>
    <Institution>
      <Name>Northeastern University</Name>
      <CityName>BOSTON</CityName>
      <ZipCode>021155005</ZipCode>
      <PhoneNumber>6173735600</PhoneNumber>
      <StreetAddress>360 HUNTINGTON AVE</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Massachusetts</StateName>
      <StateCode>MA</StateCode>
    </Institution>
    <ProgramElement>
      <Code>7798</Code>
      <Text>SOFTWARE &amp; HARDWARE FOUNDATION</Text>
    </ProgramElement>
  </Award>
</rootTag>
